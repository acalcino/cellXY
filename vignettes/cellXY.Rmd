---
title: "cellXY"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{cellXY}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r setup}
library(cellXY)
library(speckle)
library(SingleCellExperiment)
library(CellBench)
library(limma)
library(ggplot2)
library(scater)
library(patchwork)
library(edgeR)
library(AnnotationDbi)
library(org.Hs.eg.db)

```

We are using single cell data from the `r BiocStyle::Biocpkg("CellBench")` 
package to illustrate how `propeller` works. This is an artificial dataset that 
is made up of an equal mixture of 3 different cell lines. There are three 
datasets corresponding to three different technologies: 10x genomics, CelSeq and
DropSeq.

```{r}
sc_data <- load_sc_data()
```


```{r}
commongenes1 <- rownames(sc_data$sc_dropseq)[rownames(sc_data$sc_dropseq) %in% 
                                                rownames(sc_data$sc_celseq)]
commongenes2 <-  commongenes1[commongenes1 %in% rownames(sc_data$sc_10x)]
sce_10x <- sc_data$sc_10x[commongenes2,]
sce_celseq <- sc_data$sc_celseq[commongenes2,] 
sce_dropseq <- sc_data$sc_dropseq[commongenes2,] 
dim(sce_10x)
dim(sce_celseq)
dim(sce_dropseq)
table(rownames(sce_10x) == rownames(sce_celseq))
table(rownames(sce_10x) == rownames(sce_dropseq))
```


```{r}
i.10x <- seq_len(ncol(sce_10x))
i.celseq <- seq_len(ncol(sce_celseq))
i.dropseq <- seq_len(ncol(sce_dropseq))
set.seed(10)
boot.10x <- sample(i.10x, replace=TRUE)
boot.celseq <- sample(i.celseq, replace=TRUE)
boot.dropseq <- sample(i.dropseq, replace=TRUE)
sce_10x_rep2 <- sce_10x[,boot.10x]
sce_celseq_rep2 <- sce_celseq[,boot.celseq]
sce_dropseq_rep2 <- sce_dropseq[,boot.dropseq]
```

```{r}
sample <- rep(c("S1","S2","S3","S4","S5","S6"), 
                c(ncol(sce_10x),ncol(sce_10x_rep2),ncol(sce_celseq),
                ncol(sce_celseq_rep2), 
                ncol(sce_dropseq),ncol(sce_dropseq_rep2)))
cluster <- c(sce_10x$cell_line,sce_10x_rep2$cell_line,sce_celseq$cell_line,
                sce_celseq_rep2$cell_line,sce_dropseq$cell_line,
                sce_dropseq_rep2$cell_line)
group <- rep(c("10x","celseq","dropseq"),
                c(2*ncol(sce_10x),2*ncol(sce_celseq),2*ncol(sce_dropseq)))
allcounts <- cbind(counts(sce_10x),counts(sce_10x_rep2), 
                    counts(sce_celseq), counts(sce_celseq_rep2),
                    counts(sce_dropseq), counts(sce_dropseq_rep2))
sce_all <- SingleCellExperiment(assays = list(counts = allcounts))
sce_all$sample <- sample
sce_all$group <- group
sce_all$cluster <- cluster
```

# Classifying male and female cells from scRNA-seq data
A common quality control check in bulk RNA-seq is to check the sex of the 
samples. The simplest method to do this is to check expression of *XIST*, which 
is the gene responsible for X-inactivation. It is highly expressed in females, 
and not expressed in males. In experiments where the sex of the samples has not 
been recorded, the variation due to sex can often be captured by the top 
principal component in an MDS or PCA plot. It is important to know if the 
samples are a mix of males and females and to take this information 
into account in downstream analysis.
It turns out that for single cell data, it is not a simple matter to classify
cells as male or female. The main reason for this is that the cells are
much more lowly sequenced compared to bulk RNA-seq samples resulting in low or 
zero counts for many genes, including *XIST* and other X- and Y-chromosome 
genes. Thus simply trying to classify cells as male or female based on observed 
counts for *XIST* leave many cells unable to be classified.
There are a few reasons for wanting to classify male and female cells. First, it
could form part of the analysis assessing quality of the cells, and if sex is 
not information that is easily available, it is an additional variable we can 
predict from the gene expression. This may then inform further analysis of the 
data, by allowing us to take sex into account in the analysis.
We have built a classifier to predict the sex of each cell based on logistic 
regression for human and mouse cells. The input is the matrix of counts where
the genes are the rows and the cells are the columns. The rownames of the counts
matrix needs to be gene symbol. The `allcounts` data object contains the counts
for all the cells used in the `propeller` function, but the rownames are ENSEMBL
IDs. The first step is thus converting the ENSEMBL IDs to gene symbol.
```{r}
allcounts[1:5,1:5]
nc <- normCounts(allcounts, log=TRUE)
avgexp <- rowMeans(nc)
o <- order(avgexp, decreasing = TRUE)
allcounts2 <- allcounts[o,]
allcounts2[1:5,1:5]
ann <- AnnotationDbi::select(org.Hs.eg.db, keys=rownames(allcounts2),
                columns=c("ENSEMBL","SYMBOL"), keytype="ENSEMBL")
m <- match(rownames(allcounts2), ann$ENSEMBL)
symbol <- ann$SYMBOL[m]
table(duplicated(symbol))
allcounts2 <- allcounts2[!duplicated(symbol) & !is.na(symbol),]
rownames(allcounts2) <- symbol[!duplicated(symbol) & !is.na(symbol)]
table(duplicated(colnames(allcounts2)))
colnames(allcounts2) <- paste(colnames(allcounts2),1:ncol(allcounts2), sep=".")
table(duplicated(rownames(allcounts2)))
```

Now that the counts matrix is in the correct format we can call the 
`classifySex` function.
```{r}
sex <- classifySex(allcounts2, genome="Hs", qc=FALSE)
table(sex$prediction)
```

The cell lines were all derived from females, so the sex of the cells is 
correctly classified as female.
